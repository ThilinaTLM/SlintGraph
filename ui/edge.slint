import { RectangleDimensions } from "./movable-rectangle.slint";

component RotatableArrowHead inherits Path {
    in property <angle> angle: 0deg;
    
    pure function rotate-point(x: float, y: float) -> Point {
        return {
            x: (x * cos(angle) - y * sin(angle)) *1px,
            y: (x * sin(angle) + y * cos(angle)) *1px
        };
    }

    MoveTo {
        x: rotate-point(0, 50).x / 1px;
        y: rotate-point(0, 50).y / 1px;
    }
    LineTo {
        x: rotate-point(100, 0).x / 1px;
        y: rotate-point(100, 0).y / 1px;
    }
    LineTo {
        x: rotate-point(70, 50).x / 1px;
        y: rotate-point(70, 50).y / 1px;
    }
    LineTo {
        x: rotate-point(100, 100).x / 1px;
        y: rotate-point(100, 100).y / 1px;
    }
    Close {}
}


export component ArrowWrapEdge {
    in property <RectangleDimensions> from;
    in property <RectangleDimensions> to;
    in property <int> arrow-size: 10;
    in property <int> wrap-distance: arrow-size + 2;
    in property <int> from-wrap-distance: wrap-distance;
    in property <int> to-wrap-distance: wrap-distance;

    property <bool> direction-left: (from.x + from.width/2) < (to.x + to.width/2);
    property <bool> direction-up: (from.y + from.height/2) < (to.y + to.height/2);
    property <bool> x-overlap: (from.x < to.x + to.width + 10px) && (to.x < from.x + from.width + 10px);
    property <bool> y-overlap: (from.y < to.y + to.height + 10px) && (to.y < from.y + from.height + 10px);
    property <bool> wrap-edge-around: x-overlap && !y-overlap;

    property <length> start-x: direction-left ? from.x + from.width : from.x;
    property <length> start-y: from.y + from.height / 2;
    property <length> end-x: direction-left ? to.x : to.x + to.width;
    property <length> end-y: to.y + to.height / 2;

    x: min(start-x, end-x) - arrow-size*4px - 10px;
    y: min(start-y, end-y) - arrow-size*4px - 10px;
    width: abs(end-x - start-x) + arrow-size*8px + 20px;
    height: abs(end-y - start-y) + arrow-size*8px + 20px;

    edge := Path {
        width: root.width;
        height: root.height;
        viewbox-width: self.width / 1px;
        viewbox-height: self.height / 1px;
        stroke: blue;
        stroke-width: 1px;
        clip: false;
    
        MoveTo {
            x: (root.start-x - root.x) / 1px;
            y: (root.start-y - root.y) / 1px;
        }
        LineTo {
            x: (root.start-x - root.x) / 1px + (direction-left? from-wrap-distance: -from-wrap-distance);
            y: (root.start-y - root.y) / 1px;
        }
        LineTo {
            x: (root.start-x - root.x) / 1px + (direction-left? from-wrap-distance: -from-wrap-distance);
            y: (root.start-y - root.y) / 1px + (wrap-edge-around? (direction-up? from.height: -from.height)/2px: 0);
        }
        LineTo {
            x: (root.end-x - root.x) / 1px + (direction-left? -to-wrap-distance: to-wrap-distance);
            y: (root.end-y - root.y) / 1px + (wrap-edge-around? (direction-up? -to.height: to.height)/2px: 0);
        }
        LineTo {
            x: (root.end-x - root.x) / 1px + (direction-left? -to-wrap-distance: to-wrap-distance);
            y: (root.end-y - root.y) / 1px;
        }
        LineTo {
            x: (root.end-x - root.x) / 1px;
            y: (root.end-y - root.y) / 1px;
        }
    }

    RotatableArrowHead {
        width: arrow-size * 1px;
        height: arrow-size * 1px;
        stroke: edge.stroke;
        stroke-width: edge.stroke-width;
        fill: edge.stroke;

        x: end-x - root.x - (direction-left? self.width: 0);
        y: end-y - root.y - self.height / 2;
        angle: (root.direction-left? 180deg: 0);
    }
    
}